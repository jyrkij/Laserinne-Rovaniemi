/**
 * SnakeRun
 * 
 * @package FIS
 * @author Jyrki Lilja
 */

package com.laserinne.snakerun;

import java.util.ArrayList;

import blobDetection.Blob;
import blobDetection.BlobDetection;
import blobDetection.EdgeVertex;

import com.laserinne.util.Snake;
import com.laserinne.util.RandomWalkOscillator;

import geomerative.RFont;
import geomerative.RG;
import laserschein.Laser3D;
import laserschein.Laserschein;
import processing.core.PApplet;
import processing.core.PGraphics;
import processing.core.PImage;
import processing.core.PVector;
import processing.opengl.PGraphicsOpenGL;

public class SnakeRun extends PApplet {
    /**
     * Generated by Jyrki Lilja on 2011-08-09 11.01
     */
    private static final long serialVersionUID = -6130751878909898451L;
    
    private boolean laserOn = false;
    
    private Laserschein laser;
    private Laser3D renderer;
    
    private Snake leftSnake,
                  rightSnake;
    private ArrayList<PVector> leftPoints,
                               rightPoints;
    private SnakeRunSkierContestant leftSkier,
                                    rightSkier;
    private RFont font;
    
    /**
     * @field pg renders the snakes here
     */
    private PGraphics pg;
    /**
     * @field img used to detect contours
     */
    private PImage img;
    private BlobDetection bd;
    
    private static final int FINISH_LINE = 400;
    private static final int WIDTH = 640;
    private static final int HEIGHT = 480;
    
    public static final int LASER_COLOR = 0xFFFF0000;
    public static final int SCREEN_COLOR = 0xFF0000FF;
    
    public static final int NUM_FOLLOWERS = 50;
    
    /**
     * main
     * 
     * This has to be commented out when running in Processing to allow font
     * loading, but available when running in Eclipse or building with Ant /
     * exporting to application from Processing or building with Ant.
     */
    public static void main(String args[]) {
         PApplet.main(new String[] { com.laserinne.snakerun.SnakeRun.class.getName() });
    }
    
    public void setup() {
        size(SnakeRun.WIDTH, SnakeRun.HEIGHT, PGraphicsOpenGL.OPENGL);
        frameRate(-1); // Use maximum frame rate.
        laser = new Laserschein(this, Laserschein.EASYLASEUSB2);
        renderer = laser.renderer();
        
        smooth();
        
        colorMode(RGB);
        stroke(SnakeRun.SCREEN_COLOR);
        noFill();
        
        // Create the snakes
        leftSnake = new Snake(width / 4, 0, SnakeRun.NUM_FOLLOWERS);
        rightSnake = new Snake(width * 3 / 4, 0, SnakeRun.NUM_FOLLOWERS);
        // Create paths
        leftPoints = new ArrayList<PVector>();
        rightPoints = new ArrayList<PVector>();
        generatePaths();
        // Assign paths to snakes
        leftSnake.targets(leftPoints);
        rightSnake.targets(rightPoints);
        
        // Initialize fake skiers
        SnakeRunSkierContestant.processing(this);
        SnakeRunSkierContestant.finishLine(SnakeRun.FINISH_LINE);
        leftSkier = new SnakeRunSkierContestant(width / 4, 0);
        rightSkier = new SnakeRunSkierContestant(width * 3 / 4, 0);
        
        RG.init(this);
        font = new RFont("Laserfont.ttf", 80, RFont.CENTER);
        
        pg = createGraphics(width, height, PGraphics.P2D);
        img = new PImage(60, 60);
        bd = new BlobDetection(img.width, img.height);
        bd.setPosDiscrimination(true);
        bd.setThreshold(0.1f);
    }
    
    public void draw() {
        background(0);
        stroke(SnakeRun.SCREEN_COLOR);
        
        // float cameraZ = (float) ((height/2.0) / Math.tan(PI * 60.0 / 360.0));
        // perspective(PI / 3.0, width/height, cameraZ/10.0, cameraZ*10.0);
        
        float eyeX = width / 2.0f,
              eyeY = height / 2.0f,
              eyeZ = (float) ((height / 2.0) / Math.tan(PI * 60.0 / 360.0)),
              centerX = width / 2.0f,
              centerY = height / 2.0f,
              centerZ = 0,
              upX = 0,
              upY = 1,
              upZ = 0;
        camera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
        
        // rotateX(-PI * 1 / 3);
        
        // Draw FPS on screen
        pushMatrix();
        translate(30, 80);
        font.setAlign(RFont.LEFT);
        font.draw(new Integer(Math.round(frameRate)).toString());
        popMatrix();
        
        drawPath(leftPoints);
        drawPath(rightPoints);
        
        line(width / 4, 0, width / 4, height);
        line(width / 2, 0, width / 2, height);
        line(width * 3 / 4, 0, width * 3 / 4, height);
        
        if (laserOn) {
            if (leftSkier.finished())
                leftSnake.stop();
            if (rightSkier.finished())
                rightSnake.stop();
            
            leftSnake.update();
            rightSnake.update();
            
            pg.beginDraw();
            pg.background(0);
            pg.loadPixels();
            pg.stroke(255);
            pg.fill(255);
            leftSnake.draw(pg);
            rightSnake.draw(pg);
            pg.updatePixels();
            pg.endDraw();
            
            // Now, we have to threshold the image, and DETECT A CONTOUR:
            // first, copy on the small image:
            img.copy(pg, 0, 0, pg.width, pg.height, 0, 0, img.width, img.height);
            //detect the contours:
            bd.computeBlobs(img.pixels);
            
            stroke(SnakeRun.LASER_COLOR);
            beginRaw(renderer);
            drawBlobsAndEdges(false, true);
            endRaw();
            stroke(SnakeRun.SCREEN_COLOR);
            
            leftSkier.inSnake(leftSnake);
            leftSkier.draw(g);
//            rightSkier.inSnake(rightSnake);
//            rightSkier.draw(g);
            
            //image(pg, 0, 0, width, height);
        }
    }
    
    private void drawBlobsAndEdges(boolean drawBlobs, boolean drawEdges) {
        Blob b;
        EdgeVertex eA, eB;
        for (int n = 0; n < bd.getBlobNb(); n++) {
            b = bd.getBlob(n);
            if (b != null) {
                // Blobs
                if (drawBlobs) {
                    rect(
                        b.xMin * width, b.yMin * height,
                        b.w * width, b.h * height
                        );
                }
                // Edges
                if (drawEdges) {
                    for (int m = 0; m < b.getEdgeNb(); m++) {
                        eA = b.getEdgeVertexA(m);
                        eB = b.getEdgeVertexB(m);
                        if (eA != null && eB != null)
                            line(
                                eA.x * width, eA.y * height, 
                                eB.x * width, eB.y * height
                                );
                    }
                }
            }
        }
    }
    
    private void drawPath(ArrayList<PVector> points) {
        beginShape();
        for (PVector p : points) {
            // First point is the first control point as well.
            if (points.get(0) == p) {
                curveVertex(p.x, p.y);
            }
            curveVertex(p.x, p.y);
            // Last point is the last control point as well.
            if (points.get(points.size() - 1) == p) {
                curveVertex(p.x, p.y);
            }
        }
        endShape();
        
        // Show the points
        pushMatrix();
        for (PVector p : points) {
            ellipseMode(CENTER);
            ellipse(p.x, p.y, 3, 3);
        }
        popMatrix();
    }
    
    private void generatePaths() {
        int steps = 25;
        
        leftPoints.clear();
        leftPoints.add(new PVector(width * 1 / 4, 0));
        rightPoints.clear();
        rightPoints.add(new PVector(width * 3 / 4, 0));
        
        RandomWalkOscillator rwo = new RandomWalkOscillator();
        
        for (int step = 0; step <= steps; step++) {
            float walkValue = (float) rwo.nextStep();
            
            // Calculate points for left and right snakes.
            float x, y = (height / steps) * (step + 1);
            x = width / 4 + walkValue;
            if (x < width / 20) {
                x = width / 20;
            } else if (x > width * 9 / 20) {
                x = width * 9 / 20;
            }
            leftPoints.add(new PVector(x, y));
            
            x += width / 2;
            if (x < width * 11 / 20) {
                x = width * 11 / 20;
            }
            if (x > width * 19 / 20) {
                x = width * 19 / 20;
            }
            rightPoints.add(new PVector(x, y));
        }
    }
    
    private void reset() {
        leftSnake.reset(width / 4, 0, leftPoints);
        leftSnake.stop();
        leftSkier.reset();
        
        rightSnake.reset(width * 3 / 4, 0, rightPoints);
        rightSnake.stop();
        rightSkier.reset();
    }
    
    public void keyPressed() {
        if (key == CODED) {
            // Snake speed control for test purposes
            if (keyCode == UP) { // add speed for *Left snake*
                leftSnake.changeTopSpeed(0.25f);
            } else if (keyCode == DOWN) { // slow down *Left snake*
                leftSnake.changeTopSpeed(-0.25f);
            } else if (keyCode == RIGHT) { // add speed for *Right snake*
                rightSnake.changeTopSpeed(0.25f);
            } else if (keyCode == LEFT) { // slow down *Right snake*
                rightSnake.changeTopSpeed(-0.25f);
            }
        } else if (key == 'n') {
            // Generate new paths & reset positions
            generatePaths();
            reset();
            
        } else if (key == 's') {
            // Start/stop
            if (laserOn) {
                if (leftSnake.running() || rightSnake.running()) {
                    leftSnake.stop();
                    rightSnake.stop();
                } else {
                    leftSnake.start();
                    rightSnake.start();
                    // TODO: Move the skier starts according to 69149cf.
                    leftSkier.start();
                    rightSkier.start();
                }
            }
        } else if (key == 'r') {
            // Reset positions
            reset();
        } else if (key == 'l') {
            // Switch laser on/off
            laserOn = !laserOn;
        }
    }
}
