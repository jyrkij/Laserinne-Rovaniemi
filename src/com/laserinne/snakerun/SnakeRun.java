/*
 *                This file is part of Laserinne.
 * 
 *  Laser projections in public space, inspiration and
 *  information, exploring the aesthetic and interactive possibilities of
 *  laser-based displays.
 * 
 *  http://www.laserinne.com/
 * 
 * Laserinne is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Laserinne is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Laserinne. If not, see <http://www.gnu.org/licenses/>.
 */

package com.laserinne.snakerun;

import java.util.ArrayList;

import processing.core.PApplet;
import processing.core.PGraphics;
import processing.core.PImage;
import processing.core.PVector;
import blobDetection.Blob;
import blobDetection.BlobDetection;
import blobDetection.EdgeVertex;

import com.laserinne.util.RandomWalkOscillator;

/**
 * SnakeRun acts as the main class of SnakeRun application.
 * 
 * TODO: Concept of showing winner in LED vest. Automatically send/show it.
 * 
 * @author Jyrki Lilja
 */

public class SnakeRun extends com.laserinne.util.TwoPlayerCompetition {
    /**
     * Generated by Jyrki Lilja on 2011-08-09 11.01
     */
    private static final long serialVersionUID = -6130751878909898451L;
    
    private Snake leftSnake,
                  rightSnake;
    private ArrayList<PVector> leftPoints,
                               rightPoints;
    
    /**
     * @field pg renders the snakes here
     */
    private PGraphics pg;
    /**
     * @field img used to detect contours
     */
    private PImage img;
    private BlobDetection bd;
    
    public static final int NUM_FOLLOWERS = 50;
    
    /**
     * main
     * 
     * This has to be commented out when running in Processing to allow font
     * loading, but available when running in Eclipse or building with Ant /
     * exporting to application from Processing or building with Ant.
     */
    public static void main(String args[]) {
         PApplet.main(new String[] { com.laserinne.snakerun.SnakeRun.class.getName() });
    }
    
    public void setup() {
        super.setup();
        
        /*
         * Create canvas for drawing snakes and blob detection for finding the
         * outlines.
         */
        pg = createGraphics(width, height, PGraphics.P2D);
        img = new PImage(60, 60);
        bd = new BlobDetection(img.width, img.height);
        bd.setPosDiscrimination(true);
        bd.setThreshold(0.1f);
        
        // Create the snakes
        leftSnake = new Snake(width / 4, 0, SnakeRun.NUM_FOLLOWERS);
        rightSnake = new Snake(width * 3 / 4, 0, SnakeRun.NUM_FOLLOWERS);
        
        // Create paths
        leftPoints = new ArrayList<PVector>();
        rightPoints = new ArrayList<PVector>();
        
        // Initialize skiers
        leftSkier = new SnakeRunSkierContestant();
        rightSkier = new SnakeRunSkierContestant();
        
        // Reset both snakes and skiers so that we're ready to run.
        newGame();
        reset();
    }
    
    public void draw() {
        super.draw();
        
        drawPath(leftPoints);
        drawPath(rightPoints);
        
        line(width / 4, 0, width / 4, height);
        line(width * 3 / 4, 0, width * 3 / 4, height);
        
        leftSnake.update();
        rightSnake.update();
        
        pg.beginDraw();
        pg.background(0);
        pg.loadPixels();
        pg.stroke(255);
        pg.fill(255);
        leftSnake.draw(pg);
        rightSnake.draw(pg);
        pg.updatePixels();
        pg.endDraw();
        
//        leftSkier.setPosition((int) (mouseX - width * 0.3), mouseY);
        leftSkier.update();
        ((SnakeRunSkierContestant) leftSkier).inSnake(leftSnake);
        leftSkier.draw(g);
//        rightSkier.setPosition((int) (mouseX + width * 0.3), mouseY);
        rightSkier.update();
        ((SnakeRunSkierContestant) rightSkier).inSnake(rightSnake);
        rightSkier.draw(g);
        
//          image(pg, 0, 0, width, height);
        
        drawWithLaser();
    }
    
    protected void drawGame() {
        laserRenderer.smooth();
        // First of all, fill the image with black
        img.copy(pg, 0, 0, 1, 1, 0, 0, img.width, img.height);
        // Then copy the rendered pg to small image
        img.copy(pg, 0, 0, pg.width / 2, pg.height, 0, 0, img.width / 2, img.height);
        // Then detect the contours
        bd.computeBlobs(img.pixels);
        // Finally draw the edges
        drawEdgeShape();
        // And repeat for the right side of pg
        img.copy(pg, 0, 0, 1, 1, 0, 0, img.width, img.height);
        img.copy(pg, pg.width / 2, 0, pg.width / 2, pg.height, img.width / 2, 0, img.width / 2, img.height);
        bd.computeBlobs(img.pixels);
        drawEdgeShape();
    }
    
    private void drawEdgeShape() {
        Blob b;
        EdgeVertex eA;
        pushMatrix();
        beginShape();
        for (int n = 0; n < bd.getBlobNb(); n++) {
            b = bd.getBlob(n);
            if (b != null) {
                for (int m = 0; m < b.getEdgeNb(); m++) {
                    eA = b.getEdgeVertexA(m);
                    if (eA != null) {
                        vertex(eA.x * width, eA.y * height);
                    }
                }
            }
        }
        endShape(CLOSE);
        popMatrix();
    }
    
    private void drawPath(ArrayList<PVector> points) {
        beginShape();
        for (PVector p : points) {
            // First point is the first control point as well.
            if (points.get(0) == p) {
                curveVertex(p.x, p.y);
            }
            curveVertex(p.x, p.y);
            // Last point is the last control point as well.
            if (points.get(points.size() - 1) == p) {
                curveVertex(p.x, p.y);
            }
        }
        endShape();
        
        // Show the points
        pushMatrix();
        for (PVector p : points) {
            ellipseMode(CENTER);
            ellipse(p.x, p.y, 3, 3);
        }
        popMatrix();
    }
    
    private void generatePaths() {
        int steps = 25;
        
        leftPoints.clear();
        leftPoints.add(new PVector(width * 1 / 4, 0));
        rightPoints.clear();
        rightPoints.add(new PVector(width * 3 / 4, 0));
        
        RandomWalkOscillator rwo = new RandomWalkOscillator();
        
        for (int step = 0; step <= steps; step++) {
            float walkValue = (float) rwo.nextStep();
            
            // Calculate points for left and right snakes.
            float x, y = (height / steps) * (step + 1);
            
            x = constrain(width / 4 + walkValue, width / 20, width * 9 / 20);
            leftPoints.add(new PVector(x, y));
            
            x = constrain(width * 3 / 4 + walkValue, width * 11 / 20, width * 19 / 20);
            rightPoints.add(new PVector(x, y));
        }
    }
    
    protected void newGame() {
        generatePaths();
    }
    
    protected void reset() {
        super.reset();
        leftSnake.reset(width / 4, 0, leftPoints);
        leftSnake.start();
        float topSpeed = leftSnake.topSpeed();
        while (!leftSnake.closeTo(leftPoints.get(2))) {
            leftSnake.topSpeed(2.0f);
            leftSnake.update();
        }
        leftSnake.topSpeed(topSpeed);
        
        rightSnake.reset(width * 3 / 4, 0, rightPoints);
        rightSnake.start();
        topSpeed = rightSnake.topSpeed();
        while (!rightSnake.closeTo(rightPoints.get(2))) {
            rightSnake.topSpeed(2.0f);
            rightSnake.update();
        }
        rightSnake.topSpeed(topSpeed);
    }
    
    public void keyPressed() {
        if (key == CODED) {
            // Snake speed control for test purposes
            if (keyCode == UP) { // add speed for *Left snake*
                leftSnake.changeTopSpeed(0.25f);
            } else if (keyCode == DOWN) { // slow down *Left snake*
                leftSnake.changeTopSpeed(-0.25f);
            } else if (keyCode == RIGHT) { // add speed for *Right snake*
                rightSnake.changeTopSpeed(0.25f);
            } else if (keyCode == LEFT) { // slow down *Right snake*
                rightSnake.changeTopSpeed(-0.25f);
            }
        } else {
            super.keyPressed();
        }
    }
}
