/**
 *                This file is part of Laserinne.
 * 
 *  Laser projections in public space, inspiration and
 *  information, exploring the aesthetic and interactive possibilities of
 *  laser-based displays.
 * 
 *  http://www.laserinne.com/
 * 
 * Laserinne is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Laserinne is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Laserinne. If not, see <http://www.gnu.org/licenses/>.
 */

package com.laserinne.snakerun;

import geomerative.RFont;
import geomerative.RG;

import java.util.ArrayList;

import laserschein.Laser3D;
import laserschein.Laserschein;
import processing.core.PApplet;
import processing.core.PGraphics;
import processing.core.PImage;
import processing.core.PVector;
import processing.opengl.PGraphicsOpenGL;
import blobDetection.Blob;
import blobDetection.BlobDetection;
import blobDetection.EdgeVertex;

import com.laserinne.util.ContestantTracking;
import com.laserinne.util.RandomWalkOscillator;
import com.laserinne.util.Skier;
import com.laserinne.util.SkierContestant;
import com.laserinne.util.Tracking;

/**
 * SnakeRun acts as the main class of SnakeRun application.
 * 
 * @author Jyrki Lilja
 */

public class SnakeRun extends PApplet {
    /**
     * Generated by Jyrki Lilja on 2011-08-09 11.01
     */
    private static final long serialVersionUID = -6130751878909898451L;
    
    private boolean laserOn = false;
    
    private Laserschein laser;
    private Laser3D renderer;
    private ContestantTracking tracking;
    
    private Snake leftSnake,
                  rightSnake;
    private ArrayList<PVector> leftPoints,
                               rightPoints;
    private SnakeRunSkierContestant leftSkier,
                                    rightSkier;
    private RFont font;
    
    /**
     * @field pg renders the snakes here
     */
    private PGraphics pg;
    /**
     * @field img used to detect contours
     */
    private PImage img;
    private BlobDetection bd;
    
    private static final int FINISH_LINE = 400;
    private static final int WIDTH = 640;
    private static final int HEIGHT = 480;
    
    public static final int LASER_COLOR = 0xFFFF0000;
    public static final int SCREEN_COLOR = 0xFF0000FF;
    
    public static final int GAME_SCANSPEED = 12000;
    public static final int TEXT_SCANSPEED = 60000;
    
    public static final int NUM_FOLLOWERS = 50;
    
    /**
     * main
     * 
     * This has to be commented out when running in Processing to allow font
     * loading, but available when running in Eclipse or building with Ant /
     * exporting to application from Processing or building with Ant.
     */
    public static void main(String args[]) {
         PApplet.main(new String[] { com.laserinne.snakerun.SnakeRun.class.getName() });
    }
    
    public void setup() {
        size(SnakeRun.WIDTH, SnakeRun.HEIGHT, PGraphicsOpenGL.OPENGL);
        frameRate(-1); // Use maximum frame rate.
        laser = new Laserschein(this, Laserschein.EASYLASEUSB2);
        laser.output().setScanSpeed(SnakeRun.GAME_SCANSPEED);
        renderer = laser.renderer();
        
        tracking = new ContestantTracking();
        
        Skier.width(SnakeRun.WIDTH);
        Skier.height(SnakeRun.HEIGHT);
        
        smooth();
        
        colorMode(RGB);
        stroke(SnakeRun.SCREEN_COLOR);
        noFill();
        
        // Create the snakes
        leftSnake = new Snake(width / 4, 0, SnakeRun.NUM_FOLLOWERS);
        rightSnake = new Snake(width * 3 / 4, 0, SnakeRun.NUM_FOLLOWERS);
        // Create paths
        leftPoints = new ArrayList<PVector>();
        rightPoints = new ArrayList<PVector>();
        generatePaths();
        // Assign paths to snakes
        leftSnake.targets(leftPoints);
        rightSnake.targets(rightPoints);
        
        // Initialize fake skiers
        SnakeRunSkierContestant.finishLine(SnakeRun.FINISH_LINE);
        leftSkier = new SnakeRunSkierContestant();
        rightSkier = new SnakeRunSkierContestant();
        
        RG.init(this);
        font = new RFont("Laserfont.ttf", 80, RFont.CENTER);
        
        pg = createGraphics(width, height, PGraphics.P2D);
        img = new PImage(60, 60);
        bd = new BlobDetection(img.width, img.height);
        bd.setPosDiscrimination(true);
        bd.setThreshold(0.1f);
    }
    
    public void draw() {
        background(0);
        stroke(SnakeRun.SCREEN_COLOR);
        
        // float cameraZ = (float) ((height/2.0) / Math.tan(PI * 60.0 / 360.0));
        // perspective(PI / 3.0, width/height, cameraZ/10.0, cameraZ*10.0);
        
        float eyeX = width / 2.0f,
              eyeY = height / 2.0f,
              eyeZ = (float) ((height / 2.0) / Math.tan(PI * 60.0 / 360.0)),
              centerX = width / 2.0f,
              centerY = height / 2.0f,
              centerZ = 0,
              upX = 0,
              upY = 1,
              upZ = 0;
        camera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
        
        // rotateX(-PI * 1 / 3);
        
        // Draw FPS on screen
        pushMatrix();
        translate(30, 80);
        font.setAlign(RFont.LEFT);
        font.draw(new Integer(Math.round(frameRate)).toString());
        popMatrix();
        
        drawPath(leftPoints);
        drawPath(rightPoints);
        
        line(width / 4, 0, width / 4, height);
        line(width / 2, 0, width / 2, height);
        line(width * 3 / 4, 0, width * 3 / 4, height);
        
        if (laserOn) {
            if (leftSkier.finished())
                leftSnake.stop();
            if (rightSkier.finished())
                rightSnake.stop();
            
            leftSnake.update();
            rightSnake.update();
            
            pg.beginDraw();
            pg.background(0);
            pg.loadPixels();
            pg.stroke(255);
            pg.fill(255);
            leftSnake.draw(pg);
            rightSnake.draw(pg);
            pg.updatePixels();
            pg.endDraw();
            
            stroke(SnakeRun.LASER_COLOR);
            beginRaw(renderer);
            if (leftSkier.finished() && rightSkier.finished()) {
                laser.output().setScanSpeed(SnakeRun.TEXT_SCANSPEED);
                renderer.noSmooth();
                String finishNote = SkierContestant.winner(leftSkier, rightSkier);
                pushMatrix();
                translate(width / 2, height / 2);
                font.setAlign(RFont.CENTER);
                font.setSize(40);
                font.draw(finishNote);
                popMatrix();
            } else {
                laser.output().setScanSpeed(SnakeRun.GAME_SCANSPEED);
                renderer.smooth();
                // First of all, fill the image with black
                img.copy(pg, 0, 0, 1, 1, 0, 0, img.width, img.height);
                // Then copy the rendered pg to small image
                img.copy(pg, 0, 0, pg.width / 2, pg.height, 0, 0, img.width / 2, img.height);
                // Then detect the contours
                bd.computeBlobs(img.pixels);
                // Finally draw the edges
                drawEdgeShape();
                // And repeat for the right side of pg
                img.copy(pg, 0, 0, 1, 1, 0, 0, img.width, img.height);
                img.copy(pg, pg.width / 2, 0, pg.width / 2, pg.height, img.width / 2, 0, img.width / 2, img.height);
                bd.computeBlobs(img.pixels);
                drawEdgeShape();
            }
            endRaw();
            stroke(SnakeRun.SCREEN_COLOR);
            
            tracking.update();
            leftSkier.skier(tracking.firstSkierInRect(0, 0, width / 2, height));
            rightSkier.skier(tracking.firstSkierInRect(width / 2, 0, width, height));
            
//            leftSkier.setPosition((int) (mouseX - width * 0.3), mouseY);
            leftSkier.inSnake(leftSnake);
            leftSkier.draw(g);
//            rightSkier.setPosition((int) (mouseX + width * 0.3), mouseY);
            rightSkier.inSnake(rightSnake);
            rightSkier.draw(g);
            
//            image(pg, 0, 0, width, height);
        }
    }
    
    private void drawEdgeShape() {
        Blob b;
        EdgeVertex eA;
        pushMatrix();
        beginShape();
        for (int n = 0; n < bd.getBlobNb(); n++) {
            b = bd.getBlob(n);
            if (b != null) {
                for (int m = 0; m < b.getEdgeNb(); m++) {
                    eA = b.getEdgeVertexA(m);
                    if (eA != null) {
                        vertex(eA.x * width, eA.y * height);
                    }
                }
            }
        }
        endShape(CLOSE);
        popMatrix();
    }
    
    private void drawPath(ArrayList<PVector> points) {
        beginShape();
        for (PVector p : points) {
            // First point is the first control point as well.
            if (points.get(0) == p) {
                curveVertex(p.x, p.y);
            }
            curveVertex(p.x, p.y);
            // Last point is the last control point as well.
            if (points.get(points.size() - 1) == p) {
                curveVertex(p.x, p.y);
            }
        }
        endShape();
        
        // Show the points
        pushMatrix();
        for (PVector p : points) {
            ellipseMode(CENTER);
            ellipse(p.x, p.y, 3, 3);
        }
        popMatrix();
    }
    
    private void generatePaths() {
        int steps = 25;
        
        leftPoints.clear();
        leftPoints.add(new PVector(width * 1 / 4, 0));
        rightPoints.clear();
        rightPoints.add(new PVector(width * 3 / 4, 0));
        
        RandomWalkOscillator rwo = new RandomWalkOscillator();
        
        for (int step = 0; step <= steps; step++) {
            float walkValue = (float) rwo.nextStep();
            
            // Calculate points for left and right snakes.
            float x, y = (height / steps) * (step + 1);
            x = width / 4 + walkValue;
            if (x < width / 20) {
                x = width / 20;
            } else if (x > width * 9 / 20) {
                x = width * 9 / 20;
            }
            leftPoints.add(new PVector(x, y));
            
            x += width / 2;
            if (x < width * 11 / 20) {
                x = width * 11 / 20;
            }
            if (x > width * 19 / 20) {
                x = width * 19 / 20;
            }
            rightPoints.add(new PVector(x, y));
        }
    }
    
    private void reset() {
        leftSnake.reset(width / 4, 0, leftPoints);
        leftSnake.stop();
        leftSkier.reset();
        
        rightSnake.reset(width * 3 / 4, 0, rightPoints);
        rightSnake.stop();
        rightSkier.reset();
    }
    
    public void keyPressed() {
        if (key == CODED) {
            // Snake speed control for test purposes
            if (keyCode == UP) { // add speed for *Left snake*
                leftSnake.changeTopSpeed(0.25f);
            } else if (keyCode == DOWN) { // slow down *Left snake*
                leftSnake.changeTopSpeed(-0.25f);
            } else if (keyCode == RIGHT) { // add speed for *Right snake*
                rightSnake.changeTopSpeed(0.25f);
            } else if (keyCode == LEFT) { // slow down *Right snake*
                rightSnake.changeTopSpeed(-0.25f);
            }
        } else if (key == 'n') {
            // Generate new paths & reset positions
            generatePaths();
            reset();
            
        } else if (key == 's') {
            // Start/stop
            if (laserOn) {
                if (leftSnake.running() || rightSnake.running()) {
                    leftSnake.stop();
                    rightSnake.stop();
                } else {
                    leftSnake.start();
                    rightSnake.start();
                    // TODO: Move the skier starts according to 69149cf.
                    leftSkier.start();
                    rightSkier.start();
                }
            }
        } else if (key == 'r') {
            // Reset positions
            reset();
        } else if (key == 'l') {
            // Switch laser on/off
            laserOn = !laserOn;
        }
    }
}
